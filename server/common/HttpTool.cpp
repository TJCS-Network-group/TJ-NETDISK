#include <fstream>
#include <iostream>
#include <iterator>
#include <locale.h>
#include <map>
#include <regex>
#include <string>
#include <vector>
using namespace std;

//本地文件转成string
string FileToStr(string filepath)
{
    fstream f(filepath, ios::in | ios::binary);
    if (f.good())
    {
        f.unsetf(ios::skipws); // 关闭inputFile的忽略空格标志,可以文件中的保留空格
        istream_iterator<char> iter(f);
        string s(iter, istream_iterator<char>());
        return s;
    }
    else
    {
        cout << "Can't open file!Srcfile path error!" << endl;
        exit(EXIT_FAILURE);
    }
}

//转成form-data格式
string MapToString(map<string, string> data)
{
    string res = "";
    map<string, string>::iterator iter;
    for (iter = data.begin(); iter != data.end(); ++iter)
    {
        res += iter->first + "=" + iter->second + "&";
    }
    res.erase(res.end() - 1);
    return res;
}

// bool转string
string bool_to_string(bool _success)
{
    if (_success)
        return "true";
    else
        return "false";
}

/**
 * DESCRIPTION: 实现由utf8编码到gbk编码的转换
 *
 * Input: gbkStr,转换后的字符串;  srcStr,待转换的字符串; maxGbkStrlen, gbkStr的最大长度
 * Output: gbkStr
 * Returns: -1,fail;>0,success
 *
 */
int utf82gbk(char *gbkStr, const char *srcStr, int maxGbkStrlen)
{
    if (NULL == srcStr)
    {
        printf("Bad Parameter\n");
        return -1;
    }

    //首先先将utf8编码转换为unicode编码
    if (NULL == setlocale(LC_ALL, "zh_CN.utf8")) //设置转换为unicode前的码,当前为utf8编码
    {
        printf("Bad Parameter\n");
        return -1;
    }

    int unicodeLen = mbstowcs(NULL, srcStr, 0); //计算转换后的长度
    if (unicodeLen <= 0)
    {
        printf("Can not Transfer!!!\n");
        return -1;
    }
    wchar_t *unicodeStr = (wchar_t *)calloc(sizeof(wchar_t), unicodeLen + 1);
    mbstowcs(unicodeStr, srcStr, strlen(srcStr)); //将utf8转换为unicode

    //将unicode编码转换为gbk编码
    if (NULL == setlocale(LC_ALL, "zh_CN.gbk")) //设置unicode转换后的码,当前为gbk
    {
        printf("Bad Parameter\n");
        return -1;
    }
    int gbkLen = wcstombs(NULL, unicodeStr, 0); //计算转换后的长度
    if (gbkLen <= 0)
    {
        printf("Can not Transfer!!!\n");
        return -1;
    }
    else if (gbkLen >= maxGbkStrlen) //判断空间是否足够
    {
        printf("Dst Str memory not enough\n");
        return -1;
    }
    wcstombs(gbkStr, unicodeStr, gbkLen);
    gbkStr[gbkLen] = 0; //添加结束符
    free(unicodeStr);
    return gbkLen;
}

string To_gbk(string utf8_str)
{
    int maxGbkLen = sizeof(char) * utf8_str.length() * 2;
    char *buf = (char *)malloc(maxGbkLen);
    int gbkLen = utf82gbk(buf, utf8_str.c_str(), maxGbkLen);
    string gbk_str(buf, gbkLen);
    free(buf);
    if (gbkLen != -1)
        return gbk_str;
    else //不需要转
        return utf8_str;
}
int popen_cmd(string cmd, string &result)
{
    FILE *fp = popen(cmd.c_str(), "r");
    int ans;
    if (fp != NULL)
    {
        char buf[33];
        result = fgets(buf, 33, fp);
        pclose(fp);
        ans = 0;
    }
    else
    {
        ans = 1;
    }
    return ans;
}